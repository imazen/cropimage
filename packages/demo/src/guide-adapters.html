<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RIAPI Adapters Guide — crop-image</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Instrument+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./shared.css">
</head>
<body>
  <nav class="site-nav">
    <a class="logo" href="./">&lt;<span>crop-image</span>&gt;</a>
    <div class="nav-links">
      <a href="./">Demo</a>
      <a href="./guide-vanilla.html">Vanilla JS</a>
      <a href="./guide-react.html">React</a>
      <a href="./guide-svelte.html">Svelte</a>
      <a href="./guide-forms.html">Forms</a>
      <a href="./guide-adapters.html" class="active">Adapters</a>
      <a href="./api/">API Reference</a>
      <a href="https://github.com/imazen/cropimage">GitHub</a>
    </div>
  </nav>

  <div class="page">
    <div class="docs-content">
      <h1>RIAPI Adapters</h1>
      <p class="subtitle">Convert crop selections to server-compatible querystrings. Three built-in adapters cover all <a href="https://riapi.org/">RIAPI</a>-compliant servers.</p>

      <h2>What is RIAPI?</h2>
      <p>RIAPI (RESTful Image API) is a querystring-based convention for image manipulation. Instead of uploading a modified image, you describe the transformation as URL parameters and the server applies them on-the-fly. The <code>crop</code> parameter specifies a rectangle; <code>cropxunits</code> and <code>cropyunits</code> define the coordinate system.</p>

      <h2>Choosing an Adapter</h2>
      <p>Set the <code>adapter</code> attribute on the element. This controls how the crop selection is serialized to a querystring.</p>

      <table>
        <thead>
          <tr><th>Adapter</th><th>Server</th><th>Padding</th></tr>
        </thead>
        <tbody>
          <tr><td><code>generic</code></td><td>Any RIAPI server</td><td>Crop only (no padding output)</td></tr>
          <tr><td><code>imageflow</code></td><td>Imageflow Server</td><td><code>s.pad=T,R,B,L</code> (source pixels)</td></tr>
          <tr><td><code>imageresizer</code></td><td>ImageResizer (v3/v4/v5)</td><td><code>margin=T,R,B,L</code> (source pixels)</td></tr>
        </tbody>
      </table>

      <pre><code>&lt;!-- Generic (default) --&gt;
&lt;crop-image src="/photo.jpg"&gt;&lt;/crop-image&gt;

&lt;!-- Imageflow --&gt;
&lt;crop-image src="/photo.jpg" adapter="imageflow"&gt;&lt;/crop-image&gt;

&lt;!-- ImageResizer --&gt;
&lt;crop-image src="/photo.jpg" adapter="imageresizer"&gt;&lt;/crop-image&gt;</code></pre>

      <h2>Output Format</h2>

      <h3>Generic Adapter</h3>
      <p>All adapters use fractional units (<code>cropxunits=1</code>, <code>cropyunits=1</code>), so crop coordinates map directly to 0..1 fractions of the source image.</p>
      <pre><code>?crop=0.1,0.15,0.9,0.85&amp;cropxunits=1&amp;cropyunits=1</code></pre>
      <p>The generic adapter does not output padding parameters. Use it when your server doesn't support letterboxing, or when you're handling padding separately.</p>

      <h3>Imageflow Adapter</h3>
      <p>Crop uses the same <code>crop</code>/<code>cropxunits</code>/<code>cropyunits</code> parameters. When padding is present (crop-pad mode), it's serialized as <code>s.pad=T,R,B,L</code> in source pixels:</p>
      <pre><code>?crop=0,0.1,1,0.9&amp;cropxunits=1&amp;cropyunits=1&amp;s.pad=50,0,50,0</code></pre>
      <p>Padding values are <code>Math.round(fraction * sourceDimension)</code>. For a 1000x800 image with 5% top padding: <code>0.05 * 800 = 40px</code>.</p>

      <div class="note">
        <p><strong>Imageflow server note:</strong> Imageflow natively supports <code>crop</code>, <code>cropxunits</code>, and <code>cropyunits</code>. It also supports the shorthand <code>c=x1,y1,x2,y2</code> which automatically sets units to 100 (percentage mode). Padding in Imageflow is typically handled by the layout engine via <code>mode=pad</code> with target <code>w</code>/<code>h</code> dimensions rather than explicit padding parameters. The <code>s.pad</code> output from this adapter is intended for custom server-side handling — your application code should interpret it and apply padding accordingly.</p>
      </div>

      <h3>ImageResizer Adapter</h3>
      <p>Same crop format, with padding serialized as <code>margin=T,R,B,L</code> in source pixels:</p>
      <pre><code>?crop=0,0.1,1,0.9&amp;cropxunits=1&amp;cropyunits=1&amp;margin=50,0,50,0</code></pre>

      <div class="note">
        <p><strong>ImageResizer note:</strong> <code>margin</code> was part of the ImageResizer v3/v4 spec. Imageflow recognizes the key but has not yet implemented parsing for it. If your server doesn't handle <code>margin</code>, use the generic adapter and process padding in your application code.</p>
      </div>

      <h2>Bidirectional Conversion</h2>
      <p>All adapters support both directions: selection-to-querystring and querystring-to-selection. This is useful for restoring a previously saved crop.</p>

      <h3>Using the Core Library Directly</h3>
      <pre><code>import {
  GenericRiapiAdapter,
  ImageflowAdapter,
  ImageResizerAdapter,
  parseQuerystring,
} from '@imazen/crop-image-core';

// Selection → querystring
const adapter = new ImageflowAdapter();
const result = adapter.toParams(selection, sourceWidth, sourceHeight);
console.log(result.querystring);
// "?crop=0.1,0.1,0.9,0.9&cropxunits=1&cropyunits=1"

// Querystring → selection
const params = parseQuerystring('?crop=0.1,0.1,0.9,0.9&cropxunits=1&cropyunits=1');
const restored = adapter.fromParams(params, sourceWidth, sourceHeight);
// { crop: { x1: 0.1, y1: 0.1, x2: 0.9, y2: 0.9 }, pad: { top: 0, ... } }</code></pre>

      <h2>The <code>RiapiAdapter</code> Interface</h2>
      <p>All adapters implement this interface from <code>@imazen/crop-image-core</code>:</p>
      <pre><code>interface RiapiResult {
  params: Record&lt;string, string&gt;;
  querystring: string;
}

interface RiapiAdapter {
  toParams(sel: CropSelection, srcW: number, srcH: number): RiapiResult;
  fromParams(params: Record&lt;string, string&gt;, srcW: number, srcH: number): CropSelection | null;
}</code></pre>

      <h2>Custom Adapters</h2>
      <p>You can implement the <code>RiapiAdapter</code> interface for your own server's querystring format. The web component doesn't natively support custom adapter instances through attributes, but you can use the core library directly:</p>

      <pre><code>import { type RiapiAdapter, type RiapiResult, type CropSelection } from '@imazen/crop-image-core';

class MyServerAdapter implements RiapiAdapter {
  toParams(sel: CropSelection, srcW: number, srcH: number): RiapiResult {
    const { x1, y1, x2, y2 } = sel.crop;
    const params: Record&lt;string, string&gt; = {
      'rect': `${Math.round(x1 * srcW)},${Math.round(y1 * srcH)},` +
              `${Math.round((x2 - x1) * srcW)},${Math.round((y2 - y1) * srcH)}`,
    };
    const querystring = '?' + Object.entries(params)
      .map(([k, v]) =&gt; `${k}=${v}`).join('&');
    return { params, querystring };
  }

  fromParams(params: Record&lt;string, string&gt;, srcW: number, srcH: number): CropSelection | null {
    // Parse your format back to CropSelection
    return null;
  }
}

// Use with the web component via events
const adapter = new MyServerAdapter();
const cropper = document.querySelector('crop-image');

cropper.addEventListener('crop-commit', (e) =&gt; {
  const sel = e.detail.selection;
  const result = adapter.toParams(sel, sourceWidth, sourceHeight);
  console.log(result.querystring);
});</code></pre>

      <h2>Utility Functions</h2>
      <p>The core package exports helpers for working with querystrings:</p>
      <pre><code>import { buildQuerystring, parseQuerystring } from '@imazen/crop-image-core';

// Build from key-value pairs
const qs = buildQuerystring({ crop: '0.1,0.1,0.9,0.9', cropxunits: '1', cropyunits: '1' });
// "?crop=0.1%2C0.1%2C0.9%2C0.9&cropxunits=1&cropyunits=1"

// Parse back to object
const params = parseQuerystring(qs);
// { crop: "0.1,0.1,0.9,0.9", cropxunits: "1", cropyunits: "1" }</code></pre>

      <h2>Coordinate System</h2>
      <p>All adapters use the same coordinate system internally:</p>
      <ul>
        <li><strong>Crop coordinates</strong> are 0..1 fractions of the source image. <code>(0, 0)</code> is top-left, <code>(1, 1)</code> is bottom-right.</li>
        <li><strong>Padding</strong> is also 0..1 fractions internally. A <code>pad.top</code> of <code>0.1</code> means 10% of the source height. The Imageflow and ImageResizer adapters convert these to source pixels in the querystring.</li>
        <li><code>cropxunits=1</code> and <code>cropyunits=1</code> tell the server that coordinates are fractional (not pixels).</li>
      </ul>

      <h3>Imageflow's <code>c=</code> Shorthand</h3>
      <p>Imageflow also supports <code>c=x1,y1,x2,y2</code> which automatically sets <code>cropxunits=100</code> and <code>cropyunits=100</code> (percentage mode). A crop of <code>c=10,20,90,80</code> means 10%-90% horizontally, 20%-80% vertically. The adapters use fractional <code>crop=</code> instead, but if you're building URLs by hand, <code>c=</code> is more concise.</p>

      <h3>RIAPI Execution Order</h3>
      <p>In both Imageflow and ImageResizer, the processing pipeline is:</p>
      <pre><code>trim → srotate → sflip → crop → scale → filter → pad → rotate → flip</code></pre>
      <p>Crop coordinates refer to the source image before any scaling. Padding is applied after scaling.</p>

      <div class="note">
        <p><strong>Padding is only generated in <code>crop-pad</code> mode.</strong> In standard <code>crop</code> mode, the crop is constrained to 0..1 bounds and padding is always zero. Switch to <code>mode="crop-pad"</code> to allow the selection to extend beyond the image edges.</p>
      </div>

      <h2>.NET Integration</h2>
      <p>The crop-image component was designed to pair with .NET image servers. The RIAPI querystring output plugs directly into Imageflow or ImageResizer.</p>

      <h3>Imageflow Server (.NET)</h3>
      <p>Append the querystring to your image URL. Imageflow processes it on the fly.</p>
      <pre><code>// Razor Pages / MVC
&lt;img src="/images/@Model.Filename@Model.CropQuerystring&amp;width=800" /&gt;

// Or build the URL in C#
var croppedUrl = $"/images/{filename}{cropQs}&amp;width=800&amp;format=webp";</code></pre>

      <h3>ImageResizer (.NET)</h3>
      <p>Same approach — the <code>crop</code> and <code>cropxunits</code>/<code>cropyunits</code> params are native ImageResizer syntax.</p>
      <pre><code>// ASP.NET MVC
&lt;img src="@Url.Content("~/photos/" + Model.Photo)@Model.CropParams&amp;width=600" /&gt;</code></pre>

      <h3>Blazor</h3>
      <p>Use the web component directly in Blazor pages. The IIFE build auto-registers the element.</p>
      <pre><code>&lt;!-- In _Host.cshtml or index.html --&gt;
&lt;script src="https://unpkg.com/@@imazen/crop-image/dist/crop-image.iife.js"&gt;&lt;/script&gt;

&lt;!-- In a Blazor component --&gt;
&lt;crop-image src="@ImageUrl" aspect-ratio="16/9" adapter="imageflow"
  @ref="cropElement"&gt;&lt;/crop-image&gt;

&lt;button @onclick="Save"&gt;Save&lt;/button&gt;

@@code {
  private ElementReference cropElement;

  private async Task Save() {
    // Read the querystring via JS interop
    var qs = await JS.InvokeAsync&lt;string&gt;(
      "eval", "document.querySelector('crop-image').riapiQuerystring");
    // Store qs alongside the image reference
  }
}</code></pre>

      <h3>Storing Crop Data</h3>
      <p>The RIAPI querystring is a compact, URL-safe string that fully describes the crop. Store it alongside the image path in your database:</p>
      <pre><code>// C# / Entity Framework
public class Photo {
    public string Path { get; set; }
    public string CropParams { get; set; }  // e.g. "?crop=0.1,0.1,0.9,0.9&amp;cropxunits=1&amp;cropyunits=1"
}

// Render the cropped image
var url = $"/images/{photo.Path}{photo.CropParams}&amp;width=800";</code></pre>

      <h3>Any Backend</h3>
      <p>If you're not using Imageflow or ImageResizer, the <code>crop-change</code> event gives you the selection as normalized 0..1 fractions. Multiply by source dimensions to get pixel coordinates in any language:</p>
      <pre><code>// The selection.crop object: { x1, y1, x2, y2 } — all 0..1
// To get pixel rect:
int left   = (int)(crop.x1 * sourceWidth);
int top    = (int)(crop.y1 * sourceHeight);
int right  = (int)(crop.x2 * sourceWidth);
int bottom = (int)(crop.y2 * sourceHeight);</code></pre>
    </div>
  </div>

  <footer class="site-footer">
    <span>crop-image — <a href="https://github.com/imazen/cropimage">GitHub</a></span>
    <a href="./api/">Full API Reference</a>
  </footer>
</body>
</html>
